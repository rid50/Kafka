mvn spring-boot:build-image
mvn spring-boot:run

./mvnw clean package
docker-compose up --build --remove-orphans
docker compose up -d

//check our build-file for syntax-errors:
docker-compose config

//stop the containers
docker-compose down

# move to another machine
docker stop geoplugin-service
docker commit geoplugin-service geoplugin-service
docker save geoplugin-service > geoplugin-service.tar

#create a new container after move
docker load < geoplugin-service.tar
docker run -p 3000:3000 --name=geoplugin-service -d geoplugin-service

//Find the container ID or name:
docker ps

//look for kafka-storage.sh script
docker exec broker ls -l /opt/kafka/bin

docker exec broker locate kafka-storage.sh
docker exec -it <container_id> /opt/kafka/bin/kafka-storage.sh

//Delete existing data volumes
docker compose down -v

// remove all unused (dangling) volumes
docker volume rm $(docker volume ls -qf dangling=true)

//Remove all unused volumes using prune
docker volume prune -f

chmod +x /path/to/your/kafka_home/bin/kafka-storage.sh

docker run --rm -it --entrypoint opt/kafka/bin/kafka-storage apache/kafka:4.1.1 random-uuid
docker execute echo "Generated CLUSTER_ID: $KAFKA_CLUSTER_ID"

docker run -e CLUSTER_ID="my_value" -d --name <container_name> <image_name>

.\bin\windows\kafka-topics.bat --list --bootstrap-server localhost:9092

.\bin\windows\kafka-topics.bat --bootstrap-server localhost:9092 --create --topic yaruss-input

docker exec -i <container_name_or_id> /bin/sh < ./your_script.sh

docker exec broker kafka-topics --create --bootstrap-server kafka:9092 --topic yaruss-input

docker exec -it broker /opt/kafka/bin/kafka-topics.sh --create --topic yaruss-input --bootstrap-server kafka:9092 --partitions 1 --replication-factor 1
docker exec -it broker /opt/kafka/bin/kafka-topics.sh --create --topic yaruss-output --bootstrap-server kafka:9092

docker exec broker /opt/kafka/bin/kafka-topics.sh --list --bootstrap-server kafka:9092
docker exec broker /bin/kafka-topics.sh --list --bootstrap-server kafka:9092
docker exec broker /opt/bitnami/kafka/bin/kafka-topics.sh --list --bootstrap-server kafka:9092	!!!!! bitnami image

/opt/bitnami/kafka/bin/kafka-topics.sh --bootstrap-server localhost:9092 --list		!!!!! docker terminal
/opt/bitnami/kafka/bin/kafka-topics.sh --create --topic yaruss-output --bootstrap-server localhost:9092

docker exec broker /opt/bitnami/kafka/bin/kafka-topics.sh --create --topic yaruss-output --bootstrap-server kafka:9092

docker exec broker java -version
docker logs broker

docker stop broker
docker stop spring_boot_app

docker exec broker ls -l /tmp

Try Docker Debug for seamless, persistent debugging tools in any container or image â†’ docker debug broker
    Learn more at https://docs.docker.com/go/debug-cli/
	
	
//Open a shell in the broker container:
docker exec --workdir /opt/kafka/bin/ -it broker sh
docker exec -it broker sh
docker exec -it --user root broker /bin/sh

// run apk search openjdk inside a container
apk search openjdk

ls -l /opt/kafka/bin
ls -la /etc

sudo systemctl edit docker.service  //The systemctl: not found error occurs in Alpine Linux 

//OpenRC (Alpine Linux)
rc-service  edit docker.service
rc-service broker start

find / -name "docker.service"


//To configure the Docker API for access on Alpine Linux, you must modify the Docker daemon's startup configuration to listen on a TCP socket,
// as Alpine Linux typically uses OpenRC as its init system, not systemd
sudo nano /etc/docker/daemon.json
nano /etc/docker/daemon.json
{
  "hosts": ["unix:///var/run/docker.sock", "tcp://0.0.0.0:2375"]
}

//After the build/copy, run a temporary container and manually verify the file's existence and content:
docker run --rm apache/kafka:latest cat /etc/docker/daemon.json

sudo service docker restart

docker run -it --rm alpine sh

apt-get update && apt-get install -y nano	//Ubuntu

docker builder prune --all --force

echo $0: Shows the current shell instance.

docker run --rm -it --privileged --pid=host alpine:3.8 nsenter -t 1 -m -u -n -i sh

//Mount volumes for data persistence: Use the -v flag to share files or directories between the host and the container, preventing data loss when the container is removed.
docker run -v my_volume:/app/data my_image
docker run -it -v /var/run/docker.sock:/var/run/docker.sock alpine


curl --unix-socket /var/run/docker.sock http://localhost/v1.53/containers/json
curl --unix-socket /var/run/docker.sock "http://localhost/v1.53/containers/313ae4d4b8f0af4253293b493822f78d949a76401e4e70cda4a372e238006e49/logs?stdout=1"

curl --unix-socket /var/run/docker.sock -H "Content-Type: application/json" -d '{"Image": "alpine", "Cmd": ["echo", "hello world"]}' -X POST http://localhost/v1.53/containers/create

docker exec my_container /bin/bash -c "echo $PATH" -it
printf '%s\n' $PATH
docker exec my_container /bin/bash -c "printf '%s\n' $PATH" -it ????????????????????????????

docker exec -it my_container pwd

echo "<?php echo PHP_VERSION . PHP_EOL ?>" | docker exec --interactive my_container tee index.php

// systemd is an init system
/usr/lib/systemd/system/docker.service or
/lib/systemd/system/docker.service

ls -l /lib/systemd/system/docker.service

sudo systemctl list-units --type=service | grep docker // to list the actual name of the Docker service unit.
systemctl status docker.service
systemctl status hwclock
systemctl list-units --type=service --all

/etc/docker/daemon.json

// OpenRC is an init system
docker exec my_container /bin/bash service --status-all

docker exec my_container sh -c sudo

docker exec my_container sh -c find / -name "php*"
find . -type f -name "*.php"
find / -name "php*"

docker exec -it my_container sh
service --status-all

netstat -aon | findstr :80
  TCP    0.0.0.0:80             0.0.0.0:0              LISTENING       4
  TCP    192.168.1.35:52814     184.86.11.11:80        ESTABLISHED     7364
  TCP    192.168.1.35:54291     34.107.221.82:80       ESTABLISHED     16708
  TCP    192.168.1.35:54319     34.107.221.82:80       ESTABLISHED     16708
  TCP    [::]:80
  
tasklist /FI "PID eq 4"  


docker run -d --privileged -ti -v /sys/fs/cgroup:/sys/fs/cgroup:ro IMAGE_NAME /sbin/init

ENTRYPOINT ["/sbin/init"]

// listen on a default Unix socket
curl -X POST --unix-socket /var/run/docker.sock "http://localhost/v1.53/containers/web-1/stop"

// listen on a TCP socket
curl -X POST "http://localhost:2375/containers/apache-php-web-1/start"
curl -X POST "http://localhost:2375/containers/apache-php-web-1/stop"

# Check container logs
curl --unix-socket /var/run/docker.sock "http://localhost/v1.44/containers/CONTAINER_ID_OR_NAME/logs?stdout=1"

# Inspect container status
curl -s --unix-socket /var/run/docker.sock "http://localhost/v1.44/containers/CONTAINER_ID_OR_NAME/json" | jq '.State.Status'


docker compose down
ocker volume prune
